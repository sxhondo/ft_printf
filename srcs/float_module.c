/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   float_module.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sxhondo <w13cho@gmail.com>                 +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/08/29 16:37:57 by sxhondo           #+#    #+#             */
/*   Updated: 2019/08/29 16:37:59 by sxhondo          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/ft_printf.h"

//what should be: 	0010100000010000011000100100110111010010111100011010
//my:				0010100000010000011000100100110111010010111100011010

void		 		fraction(double num, char s[])
{
	uint64_t		res;
	int 			whole[52];
	int 			i;

	i = 0;
	while (i < 52)
	{
		num = (double)num * 2; // последовательно умножаем дробную часть на основание 2
		whole[i] = (int)num; // получаем целую часть
		if (i == 0)
			num += 0.0005; // смещение
		if ((int)num >= 1)
			num -= (int)num;
		i++;
	}
	i = -1;
	while (++i < 52)
		*s++ = whole[i] + '0';
}

//		446.156250
//		s0 e10000000111 m0010100000010000011000100100110111010010111100011010

void 				get_dnum(double dnum, t_fmt	*fmt)
{
	int 			whole = (int)dnum; //Получаем целую часть
	char 			whole_ch[100];
	double 			fract = dnum - whole; //Получаем дробную часть
	char 			fract_ch[100];
	char 			whole_fract[100];
	char 			tab[100];
	char 			*t = tab;


	itoa_base(whole, whole_ch, 0, 2); // Получаем двоичное представление целой части
	fraction(fract, fract_ch); // Получаем двоичное представление дробной части

	printf("446\t\t\t\t\t0.15625 \n");
	printf("%s\t\t\t%s\n\n", whole_ch, fract_ch);

	//	В итоге получаем число: 110111110.00101000000100000110001001001101110100101111000110102
	//	Сдвинем число на 8 разрядов вправо.
	//	В результате мы получили основные составляющие экспоненциального нормализованного двоичного числа:
	//	Мантисса M=1.101111100010100000010000011000100100110111010010111100011010
	//	Экспонента exp2=8

	tab[0] = whole_ch[0];
	ft_strcat(t, ".");
	ft_strcat(t, whole_ch + 1);
	ft_strcat(t, fract_ch);
	printf("mant: \t\t\t\t%s", t);

//	Преобразование двоичного нормализованного числа в 32 битный формат IEEE 754.
//	Первый бит отводится для обозначения знака числа. Поскольку число положительное, то первый бит равен 0
//	Следующие 8 бит (с 2-го по 9-й) отведены под экспоненту.
//	Для определения знака экспоненты, чтобы не вводить ещё один бит знака,
//	добавляют смещение к экспоненте в половину байта +127.
//	Таким образом, наша экспонента: 8 + 127 = 135
//	Переведем экспоненту в двоичное представление.
//	135 = 100001112

	printf("\n\nEXP: 8 + 127 = 135 = 10000111\n\n");

//	Оставшиеся 23 бита отводят для мантиссы. Значит из значения мантиссы нам нужно 23 символа
//	У нормализованной двоичной мантиссы первый бит всегда равен 1, так как число лежит в диапазоне 1 ≤ M < 2.
//	Для экономии, единицу не записывают, а записывают только остаток от мантиссы: 10111110001010000001000
//	Для перевода необходимо умножить разряд числа на соответствующую ему степень разряда.
//	10111110001010000001000 = 2^22*1 + 2^21*0 + ... = 6231048 = десятичное выражение мантиссы


}